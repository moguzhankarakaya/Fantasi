#version 430
#define FAR_CLIP 10000.0f
#pragma optionNV(unroll all)

uniform uint NumSpheres;
uniform writeonly image2D destTex;

layout (local_size_x = 16, local_size_y = 16) in;

struct Sphere
{
	vec3 pos;
	float r;
};

struct Ray
{
	vec3 origin;
	vec3 dir;
};

layout(std430, binding = 1) buffer SpheresBuffer
{
	Sphere spheres[];
};

float FindRaySphereIntersection(Ray r, Sphere s)
{
	vec3 oc = r.origin - s.pos;
	float p = -dot(r.dir, oc);
	float d = p*p - dot(oc,oc) + s.r*s.r;
	if (d < 0)
	{
		return FAR_CLIP;
	}
	else if (d == 0)
	{
		return (p < 0) ? FAR_CLIP : p;
	}
	else
	{
		float t1 = sqrt(d);
		float t2 = p + t1;
		t1 = p - t1;

		// If the ray started inside the sphere, we don't render it
		if ( (t1 < 0.0 && t2 > 0.0) || (t1 > 0.0 && t2 < 0.0) )
		{
			return FAR_CLIP;
		}

		if ( min(t1, t2) < 0.0)
		{
			return FAR_CLIP;
		}
		else
		{
			return min(t1, t2);
		}
	}
}

void main()
{
	ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
	imageStore(destTex, storePos, vec4(0.0, 0.0, 0.0, 1.0));
	
	vec3 RayDir = vec3(storePos.x - 256.0, storePos.y - 256.0, 512.0);
	Ray r = Ray(vec3(0.0, 0.0, 0.0), normalize(RayDir));
	for (int i=0; i<NumSpheres; i++)
	{
		float t = FindRaySphereIntersection(r, spheres[i]);
		if (t > 0.0f && t < FAR_CLIP)
		{
			imageStore(destTex, storePos, vec4(1.0, 1.0, 1.0, 1.0));
			break;
		}
	}
}
